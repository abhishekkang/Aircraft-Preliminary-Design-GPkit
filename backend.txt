
import numpy as np
from gpkit import Model, parse_variables,units
from gpkitmodels.GP.materials import cfrpud, cfrpfabric, foamhd
from gpkitmodels import g
from numpy import pi


class Planform(Model):
    """ Planform Area Definition

    Scalar Variables
    ---------
    S                                   [ft^2]  surface area
    AR                                  [-]     aspect ratio
    b                                   [ft]    span
    tau                                 [-]     airfoil thickness ratio
    CLmax           1.39                [-]     maximum lift coefficient
    CM              0.14                [-]     wing moment coefficient
    croot                               [ft]    root chord
    cmac                                [ft]    mean aerodynamic chord
    lam             0.5                 [-]     taper ratio
    cbarmac         self.return_cmac    [-]     non-dim MAC

    Variables of length N
    ---------------------
    eta         np.linspace(0,1,N)      [-]     (2y/b)
    cbar        self.return_c           [-]     non-dim chord at nodes

    Variables of length N-1
    -----------------------
    cave                                [ft]    mid section chord
    cbave       self.return_avg         [-]     non-dim mid section chord
    deta        self.return_deta        [-]     \\Delta (2y/b)

    Upper Unbounded
    ---------------  # bounding any pair of variables will work
    cave, b, tau

    Lower Unbounded
    ---------------
    cave, b, tau

    LaTex Strings
    -------------
    tau         \\tau
    CLmax       C_{L_{\\mathrm{max}}}
    CM          C_M
    croot       c_{\\mathrm{root}}
    cmac        c_{\\mathrm{MAC}}
    lam         \\lambda
    cbarmac     \\bar{c}_{\\mathrm{MAC}}

    """
    def return_c(self, c):
        " return normalized chord distribution "
        lam = c(self.lam).to("dimensionless").magnitude
        eta = c(self.eta).to("dimensionless").magnitude
        return np.array([2./(1+lam)*(1+(lam-1)*e) for e in eta])

    def return_cmac(self, c):
        " return normalized MAC "
        cbar = self.return_c(c)
        lam = cbar[1:]/cbar[:-1]
        maci = 2./3*cbar[:-1]*(1 + lam + lam**2)/(1 + lam)
        deta = np.diff(c(self.eta).to("dimensionless").magnitude) 
        num = sum([(cbar[i] + cbar[i+1])/2*maci[i]*deta[i] for i
                   in range(len(deta))])
        den = sum([(cbar[i] + cbar[i+1])/2*deta[i] for i in range(len(deta))])
        return num/den/cbar[0]

    return_avg = lambda self, c: (self.return_c(c)[:-1]
                                  + self.return_c(c)[1:])/2.
    return_deta = lambda self, c: np.diff(c(self.eta).to("dimensionless").magnitude)

    @parse_variables(__doc__, globals())
    def setup(self, N):
        return [b**2 == S*AR,
                cave == cbave*S/b,
                croot == S/b*cbar[0],
                cmac == croot*cbarmac]




class SparLoading(Model):
    """ Spar Loading Model

    Variables
    ---------
    Nmax            5              [-]     max loading
    Nsafety         1.0            [-]     safety load factor
    kappa           0.2            [-]     max tip deflection ratio
    W                              [lbf]   loading weight
    N                              [-]     loading factor
    twmax           15.*pi/180     [-]     max tip twist
    Stip            1e-10          [N]     tip loading
    Mtip            1e-10          [N*m]   tip moment
    throot          1e-10          [-]     root deflection angle
    wroot           1e-10          [m]     root deflection

    Variables of length wing.N
    --------------------------
    q                       [N/m]   distributed wing loading
    S                       [N]     shear along wing
    M                       [N*m]   wing section root moment
    th                      [-]     deflection angle
    w                       [m]     wing deflection

    Variables of length wing.N-1
    ----------------------------
    Mtw                     [N*m]   local moment due to twisting
    theta                   [-]     twist deflection
    EIbar                   [-]     EIbar
    Sout                    [-]     outboard variable

    LaTex Strings
    -------------
    Nmax                N_{\\mathrm{max}}
    kappa               \\kappa
    Mr                  M_r

    """
    def new_qbarFun(self, c):
        " define qbar model for chord loading "
        barc = self.wing.planform.cbar
        return [f(c) for f in self.wing.substitutions[barc]]

    new_SbarFun = None

    @parse_variables(__doc__, globals())
    def setup(self, wing, state, out=False):
        self.wing = wing

        b = self.b = self.wing.planform.b
        I = self.I = self.wing.spar.I
        Sy = self.Sy = self.wing.spar.Sy
        cave = self.cave = self.wing.planform.cave
        cbar = self.cbar = self.wing.planform.cbar
        E = self.wing.spar.material.E
        sigma = self.wing.spar.material.sigma
        deta = self.wing.planform.deta

        constraints = []
        if not out:
            constraints.extend([
                S[:-1] >= S[1:] + 0.5*deta*(b/2.)*(q[:-1] + q[1:]),
                M[:-1] >= M[1:] + 0.5*deta*(b/2)*(S[:-1] + S[1:])])

        constraints.extend([
            N == Nsafety*Nmax, q >= N*W/b*cbar,
            S[-1] >= Stip, M[-1] >= Mtip, th[0] >= throot,
            th[1:] >= th[:-1] + 0.5*deta*(b/2)*(M[1:] + M[:-1])/E/I,
            w[0] >= wroot, w[1:] >= w[:-1] + 0.5*deta*(b/2)*(th[1:] + th[:-1]),
            sigma >= M[:-1]/Sy, w[-1]/(b/2) <= kappa,
            ])

        self.wingSparJ = hasattr(self.wing.spar, "J")

        if self.wingSparJ:
            qne = self.qne = state.qne
            J = self.J = self.wing.spar.J
            G = self.wing.spar.shearMaterial.G
            cm = self.wing.planform.CM
            constraints.extend([
                Mtw >= cm*cave**2*qne*deta*b/2*Nsafety,
                theta[0] >= Mtw[0]/G/J[0]*deta[0]*b/2,
                theta[1:] >= theta[:-1] + Mtw[1:]/G/J[1:]*deta[1:]*b/2,
                twmax >= theta[-1]
                ])
        return constraints

class CapSpar(Model):
    """ Cap Spar Model

    Scalar Variables
    ----------------
    E               2e7     [psi]       Young modulus of CFRP
    W                       [lbf]       spar weight
    wlim            0.15    [-]         spar width to chord ratio
    mfac            0.97    [-]         curvature knockdown factor

    Variables of length N-1
    -----------------------
    hin                     [in]        height between caps
    I                       [m^4]       spar x moment of inertia
    Sy                      [m^3]       section modulus
    dm                      [kg]        segment spar mass
    w                       [in]        spar width
    t                       [in]        spar cap thickness
    tshear                  [in]        shear web thickness

    Upper Unbounded
    ---------------
    W, cave, tau

    Lower Unbounded
    ---------------
    Sy, b, surface.deta

    LaTex Strings
    -------------
    wlim                    w_{\\mathrm{lim}}
    mfac                    m_{\\mathrm{fac}}
    hin                     h_{\\mathrm{in}_i}
    I                       I_i
    Sy                      S_{y_i}
    dm                      \\Delta{m}
    w                       w_i
    t                       t_i
    tshear                  t_{\\mathrm{shear}_i}

    """
    loading = SparLoading
    material = cfrpud
    shearMaterial = cfrpfabric
    coreMaterial = foamhd



    @parse_variables(__doc__, globals())
    def setup(self, N, surface):
        self.surface = surface

        cave = self.cave = surface.cave
        b = self.b = surface.b
        deta = surface.deta
        tau = self.tau = surface.tau
        rho = self.material.rho
        rhoshear = self.shearMaterial.rho
        rhocore = self.coreMaterial.rho
        tshearmin = self.shearMaterial.tmin

        return [I/mfac <= 2*w*t*(hin/2)**2,
                dm >= (rho*(2*w*t) + 2*tshear*rhoshear*(hin + 2*t)
                       + rhocore*w*hin)*b/2*deta,
                W >= 2*dm.sum()*g,
                w <= wlim*cave,
                cave*tau >= hin + 2*t,
                Sy*(hin/2 + t) <= I,
                tshear >= tshearmin,
               ]
    
class WingSkin(Model):
    """ Wing Skin model

    Variables
    ---------
    W                           [lbf]           wing skin weight
    t                           [in]            wing skin thickness
    Jtbar           0.01114     [1/mm]          torsional moment of inertia
    Cmw             0.121       [-]             negative wing moment coeff
    rhosl           1.225       [kg/m^3]        sea level air density
    Vne             45          [m/s]           never exceed vehicle speed

    Upper Unbounded
    ---------------
    W, surface.croot

    Lower Unbounded
    ---------------
    surface.S

    LaTex Strings
    -------------
    W       W_{\\mathrm{skin}}
    t       t_{\\mathrm{skin}}
    Jtbar   \\bar{J/t}
    Cmw     C_{m_w}
    rhosl   \\rho_{\\mathrm{SL}}
    Vne     V_{\\mathrm{NE}}

    """
    material = cfrpfabric

    @parse_variables(__doc__, globals())
    def setup(self, surface):
        self.surface = surface

        croot = surface.croot
        S = surface.S
        rho = self.material.rho
        tau = self.material.tau
        tmin = self.material.tmin

        return [W >= rho*S*2*t*g,
                t >= tmin,
                tau >= 1/Jtbar/croot**2/t*Cmw*S*rhosl*Vne**2]

class WingCore(Model):
    """ Wing Core Model

    Variables
    ---------
    W                           [lbf]       wing core weight
    Abar            0.0753449   [-]         normalized cross section area

    Upper Unbounded
    ---------------
    W

    Lower Unbounded
    ---------------
    cave, b, surface.deta

    LaTex Strings
    -------------
    rhocore                 \\rho_{\\mathrm{core}}
    Abar                    \\bar{A}

    """
    material = foamhd

    @parse_variables(__doc__, globals())
    def setup(self, surface):
        self.surface = surface

        cave = self.cave = surface.cave
        b = self.b = surface.b
        deta = surface.deta
        rho = self.material.rho

        return [W >= 2*(g*rho*Abar*cave**2*b/2*deta).sum()]


class Wing(Model):
    """
    Wing Model

    Variables
    ---------
    W                   [lbf]       wing weight
    mfac        1.2     [-]         wing weight margin factor
    n_plies     5       [-]         number of plies on skin

    SKIP VERIFICATION

    Upper Unbounded
    ---------------
    W, planform.tau (if not sparJ)

    Lower Unbounded
    ---------------
    planform.b, spar.Sy (if sparModel), spar.J (if sparJ)

    LaTex Strings
    -------------
    mfac                m_{\\mathrm{fac}}

    """

    sparModel = CapSpar
    fillModel = WingCore
    #flight_model = WingAero
    skinModel = WingSkin
    sparJ = False

    @parse_variables(__doc__, globals())
    def setup(self, N=5):
        self.N = N
        self.planform = Planform(N)
        self.components = []

        if self.skinModel:
            self.skin = self.skinModel(self.planform)
            self.components.extend([self.skin])
        if self.sparModel:
            self.spar = self.sparModel(N, self.planform)
            self.components.extend([self.spar])
            self.sparJ = hasattr(self.spar, "J")
        if self.fillModel:
            self.foam = self.fillModel(self.planform)
            self.components.extend([self.foam])

        constraints = [
        self.spar.t[0:-2] == self.spar.t[-1],
        self.spar.w[0:-2] == self.spar.w[-1],
        self.skin.t >= n_plies*self.skin.material.tmin,
        W/mfac >= sum(c["W"] for c in self.components)]
        return constraints, self.planform, self.components
import numpy as np
from numpy import pi
from gpkit import Model, parse_variables, Variable, VectorVariable, units,Vectorize
from beam import Beam
from gpkitmodels import g
from tube_spar import TubeSpar
from wing_struct import *

class TailAero(Model):
    """Tail Aero Model

    Variables
    ---------
    Re          [-]     Reynolds number
    Cd          [-]     drag coefficient

    Upper Unbounded
    ---------------
    Cd, Re, S, V, b, rho

    Lower Unbounded
    ---------------
    S, tau, V, b, rho

    LaTex Strings
    -------------
    Cd      C_d

    """
    @parse_variables(__doc__, globals())
    def setup(self, static, state):
        self.state = state

        cmac = self.cmac = static.planform.cmac
        b = self.b = static.planform.b
        S = self.S = static.planform.S
        tau = self.tau = static.planform.tau
        rho = self.rho = state.rho
        V = self.V = state.V
        mu = self.mu = state.mu
        constraints = [
            Re == V*rho*S/b/mu,
            Cd>= 0.339937756*Re**(-0.181990628)*tau**(0.774603933),
            Cd>= 5.446864658*Re**(-0.484866619)*tau**(0.246341522),
            Cd>= 16.2594679*Re**(-0.539943202)*tau**(0.466384455),
            Cd>=9.509193806*Re**(-0.482346958)*tau**(0.467466389),
            Cd>= 218.7365501*Re**(-0.603870895)*tau**(1.312443752),
            ]
        return constraints

class TailBoomAero(Model):
    """ Tail Boom Aero Model

    Variables
    ---------
    Cf          [-]     tail boom skin friction coefficient
    Re          [-]     tail boom reynolds number

    Upper Unbounded
    ---------------
    Re, Cf, l, V, rho

    Lower Unbounded
    ---------------
    l, V, rho

    LaTex Strings
    -------------
    Cf      C_f

    """
    @parse_variables(__doc__, globals())
    def setup(self, static, state):
        self.state = state

        l = self.l = static.l
        rho = self.rho = state.rho
        V = self.V = state.V
        mu = self.mu = state.mu

        return [Re == V*rho*l/mu,
                Cf >= 0.455/Re**0.3,
               ]

class HorizontalTail(Wing):
    """ Horizontal Tail Model

    Variables
    ---------
    Vh                          [-]     horizontal tail volume coefficient
    lh                          [ft]    horizontal tail moment arm
    CLhmin              0.75    [-]     max downlift coefficient
    mh                          [-]     horizontal tail span effectiveness

    Upper Unbounded
    ---------------
    lh, Vh, W, planform.tau

    Lower Unbounded
    ---------------
    lh, Vh, planform.b, mh, planform.tau (if not sparModel)
    spar.Sy (if sparModel), spar.J (if sparJ)

    LaTex Strings
    -------------
    Vh          V_{\\mathrm{h}}
    lh          l_{\\mathrm{h}}
    CLmin       C_{L_{\\mathrm{min}}}
    mh          m_{\\mathrm{h}}

    """
    flight_model = TailAero
    sparModel = CapSpar
    skinModel = WingSkin
    fillModel = None

    @parse_variables(__doc__, globals())
    def setup(self, N=5):
        self.ascs = Wing.setup(self, N)
        #self.Sy =Wing.sparModel.Sy
        self.planform.substitutions.update(
            {self.planform.AR: 4, self.planform.lam: 0.8})
        

        return self.ascs, mh*(1+2.0/self.planform["AR"]) <= 2*np.pi

    
" vertical tail "
class VerticalTail(Wing):
    """ Vertical Tail Model

    Variables
    ---------
    Vv                  [-]         vertical tail volume coefficient
    lv                  [ft]        vertical tail moment arm

    Upper Unbounded
    ---------------
    lv, Vv, W, planform.tau

    Lower Unbounded
    ---------------
    lv, Vv, planform.b, planform.tau (if not sparModel)
    spar.Sy (if sparModel), spar.J (if sparJ)

    LaTex Strings
    -------------
    Vv      V_{\\mathrm{v}}
    lv      l_{\\mathrm{v}}

    """

    flight_model = TailAero
    sparModel = CapSpar
    skinModel = WingSkin
    fillModel = None

    @parse_variables(__doc__, globals())
    def setup(self, N=5):
        self.ascs = Wing.setup(self, N)
        self.planform.substitutions.update(
            {self.planform.lam: 0.8, self.planform.AR: 4})
    
        return self.ascs
    
class TailBoomBending(Model):
    """ Tail Boom Bending

    Variables
    ---------
    F                       [N]     tail force
    th                      [-]     tail boom deflection angle
    kappa           0.1     [-]     max tail boom deflection
    Nsafety         1.0     [-]     safety load factor

    Variables of length tailboom.N-1
    --------------------------------
    Mr                      [N*m]   section root moment


    Upper Unbounded
    ---------------
    tailboom.I0, tailboom.Sy
    tailboom.J (if tailboomJ), tailboom.I

    Lower Unbounded
    ---------------
    htail.planform.S, htail.planform.CLmax
    tailboom.l, tailboom.deta
    state.qne

    LaTex Strings
    -------------
    th      \\theta
    thmax   \\theta_{\\mathrm{max}}

    """
    @parse_variables(__doc__, globals())
    def setup(self, tailboom, htail, state):
        N = self.N = tailboom.N
        self.state = state
        self.htail = htail
        self.tailboom = tailboom

        Beam.qbarFun = [1e-10]*N
        Beam.SbarFun = [1.]*N
        beam = self.beam = Beam(N)

        I = tailboom.I
        tailboom.I0 = I[0]
        l = tailboom.l
        S = htail.planform.S
        E = tailboom.material.E
        Sy = tailboom.Sy
        qne = state.qne
        CLmax = htail.planform.CLmax
        deta = tailboom.deta
        sigma = tailboom.material.sigma

        constraints = [beam.dx == deta,
                       F >= qne*S,
                       beam["\\bar{EI}"] <= E*I/F/l**2/2,
                       Mr >= beam["\\bar{M}"][:-1]*F*l,
                       sigma >= Mr/Sy,
                       th == beam["\\theta"][-1],
                       beam["\\bar{\\delta}"][-1]*CLmax*Nsafety <= kappa]

        self.tailboomJ = hasattr(tailboom, "J")
        if self.tailboomJ:
            constraints.append(tailboom.J >= 1e-10*units("m^4"))

        return constraints, beam

class TailBoom(TubeSpar):
    """ Tail Boom Model

    Variables
    ---------
    l                           [ft]        tail boom length
    S                           [ft^2]      tail boom surface area
    b                           [ft]        twice tail boom length
    deta          1./(N-1)      [-]         normalized segment length
    tau           1.0           [-]         thickness to width ratio
    rhoA          0.15          [kg/m^2]    total aerial density

    Variables of length N-1
    -----------------------
    cave                        [in]        average segment width

    """

    flight_model = TailBoomAero
    tailLoad = TailBoomBending
    secondaryWeight = None

    @parse_variables(__doc__, globals())
    def setup(self, N=5):
        self.N = N
        self.spar = super(TailBoom, self).setup(N, self)

        if self.secondaryWeight:
            self.weight.right += rhoA*g*S

        d0 = self.d0 = self.d[0]

        return self.spar, [S == l*pi*d0, b == 2*l]

" tube spar "
from numpy import pi
from gpkitmodels.GP.materials import cfrpfabric
from gpkitmodels import g
from gpkit import Model, parse_variables

class TubeSpar(Model):
    """ Tail Boom Model

    Variables
    ---------
    mfac        1.0             [-]         weight margin factor
    k           0.8             [-]         taper index
    kfac        self.minusk2    [-]         (1-k/2)
    W                           [lbf]       spar weight

    Variables of length N-1
    -----------------------
    I                           [m^4]       moment of inertia
    d                           [in]        diameter
    t                           [in]        thickness
    dm                          [kg]        segment mass
    Sy                          [m^3]       section modulus

    Upper Unbounded
    ---------------
    W

    Lower Unbounded
    ---------------
    J, l, I0

    LaTex Strings
    -------------
    kfac        (1-k/2)
    mfac        m_{\\mathrm{fac}}

    """

    minusk2 = lambda self, c: 1-c(self.k)/2.
    material = cfrpfabric

    @parse_variables(__doc__, globals())
    def setup(self, N, surface):
        deta = surface.deta
        tmin = self.material.tmin
        rho = self.material.rho
        l = surface.l

        self.weight = W/mfac >= g*dm.sum()

        return [I <= pi*t*d**3/8.0,
                Sy <= 2*I/d,
                dm >= pi*rho*d*deta*t*kfac*l,
                self.weight,
                t >= tmin]
" discretized beam model "
from gpkit import Model, Variable, Vectorize

#pylint: disable=invalid-name

class Beam(Model):
    """discretized beam bending model

    Upper Unbounded
    ---------------
    EIbar, dbar_tip

    Lower Unbounded
    ---------------
    dx, qbar (if not qbarFun)

    """
    qbarFun = None
    SbarFun = None
    MbarFun = None

    def setup(self, N):

        with Vectorize(N-1):
            EIbar = self.EIbar = Variable("\\bar{EI}", "-",
                             "normalized YM and moment of inertia")
            dx = self.dx = Variable("dx", "-", "normalized length of element")

        with Vectorize(N):
            Sbar = Variable("\\bar{S}", self.SbarFun, "-", "normalized shear")
            Mbar = Variable("\\bar{M}", self.MbarFun, "-", "normalized moment")
            th = Variable("\\theta", "-", "deflection slope")
            dbar = Variable("\\bar{\\delta}", "-", "normalized displacement")
            self.dbar_tip = dbar[-1]


        throot = Variable("\\theta_{root}", 1e-10, "-", "Base angle")
        dbarroot = Variable("\\bar{\\delta}_{root}", 1e-10, "-",
                            "Base deflection")

        constraints = []
        if self.SbarFun is None:
            with Vectorize(N):
                qbar = self.qbar = Variable("\\bar{q}", self.qbarFun, "-",
                                            "normalized loading")
            Sbartip = Variable("\\bar{S}_{tip}", 1e-10, "-", "Tip loading")
            constraints.extend([
                Sbar[:-1] >= Sbar[1:] + 0.5*dx*(qbar[:-1] + qbar[1:]),
                Sbar[-1] >= Sbartip])

        if self.MbarFun is None:
            Mbartip = Variable("\\bar{M}_{tip}", 1e-10, "-", "Tip moment")
            constraints.extend([
                Mbar[:-1] >= Mbar[1:] + 0.5*dx*(Sbar[:-1] + Sbar[1:]),
                Mbar[-1] >= Mbartip])

        constraints.extend([
            th[0] >= throot,
            th[1:] >= th[:-1] + 0.5*dx*(Mbar[1:] + Mbar[:-1])/EIbar,
            dbar[0] >= dbarroot,
            dbar[1:] >= dbar[:-1] + 0.5*dx*(th[1:] + th[:-1]),
            ])

        return constraints
from gpkit import Model, parse_variables, Vectorize, SignomialEquality,Variable,units
import gpkit
class Powertrain(Model):
    """ Powertrain
    Variables
    ---------
    m                       [kg]            single powertrain mass
    Pmax                    [kW]            maximum power
    P_m_sp_cont             [W/kg]          continuous motor specific power
    P_m_sp_max              [W/kg]          maximum motor specific power
    tau_sp_max              [N*m/kg]        max specific torque
    RPMmax                  [rpm]           max rpm
    r                       [m]             propeller radius
    eta                     [-]             powertrain efficiency
    a             1         [W/kg]          dum
    RPM_margin    0.9       [-]             rpm margin
    tau_margin    0.95      [-]             torque margin
    P_margin      0.5       [-]             power margin (helpful for tail sizing)
    """
    @parse_variables(__doc__,globals())
    def setup(self):
        with gpkit.SignomialsEnabled():
            constraints = [P_m_sp_cont <= P_margin*(61.8*units("W/kg**2")*m + 6290*units("W/kg")), #magicALL motor fits
                           P_m_sp_max <= P_margin*(86.2*units("W/kg**2")*m + 7860*units("W/kg")),  #magicALL motor fits
                           eta/1*units("kg**(0.0134)") <= 0.906*m**(0.0134),
                           (RPMmax/RPM_margin)*m**(0.201) == 7939*units("rpm*kg**0.201"),
                           Pmax <= m*P_m_sp_max]
        return constraints

class Battery(Model):
    """ Battery
    Variables
    ---------
    m                   [kg]            battery total mass
    Estar       200     [Wh/kg]         battery cell specific energy
    E_capacity          [Wh]            battery total energy capacity
    P_max_cont  2160    [W/kg]          battery cell continuous specific power
    P_max_burst 5190    [W/kg]          battery cell burst specific power
    eta_pack    0.8     [-]             battery packing efficiency
    """
    @parse_variables(__doc__,globals())
    def setup(self):

        with gpkit.SignomialsEnabled():
            constraints = [m >= E_capacity/(eta_pack*Estar),
                        ]
        return constraints
    def dynamic(self,state,powermode=True):
        return BatteryP(self,state,powermode)
    
class BatteryP(Model):
    """BatteryP
    Variables
    ---------
    P                   [kW]        battery power draw
    """
    @parse_variables(__doc__,globals())
    def setup(self,batt,state,powermode):
        if powermode == True:
         constraints = [P <= batt.m*batt.P_max_burst*batt.eta_pack,]
        else:
         constraints = [P <= batt.m*batt.P_max_cont*batt.eta_pack, ]
        return constraints
import gpkit
from gpkit import Model, parse_variables, Vectorize, SignomialEquality,Variable,units
from battm import *
from wing_struct import Planform,WingSkin,CapSpar
import math
import numpy as np
pi = math.pi 

class Wing(Model):
    """
    Wing Model
    Variables
    ---------
    W                   [lbf]       wing weight
    mfac        1.2     [-]         wing weight margin
    n_plies     5       [-]         number of plies on skin

    Upper Unbounded
    ---------------
    W, planform.tau

    Lower Unbounded
    ---------------
    planform.b, spar.Sy

    LaTex Strings
    -------------
    mfac                m_{\\mathrm{fac}}

    """

    sparModel = CapSpar
    fillModel = False
    skinModel = WingSkin
    @parse_variables(__doc__,globals())
    def setup(self, N=4):
        self.N = N

        self.planform = Planform(N)
        self.b = self.planform.b
        self.components = []

        if self.skinModel:
            self.skin = self.skinModel(self.planform)
            self.components.extend([self.skin])
        if self.sparModel:
            self.spar = self.sparModel(N, self.planform)
            self.components.extend([self.spar])
            self.Sy = self.spar.Sy
        if self.fillModel:
            self.foam = self.fillModel(self.planform)
            self.components.extend([self.foam])

        constraints = [
        self.spar.t[0:-2] == self.spar.t[-1],
        self.spar.w[0:-2] == self.spar.w[-1],
        self.skin.t >= n_plies*self.skin.material.tmin,
        W/mfac >= sum(c["W"] for c in self.components)]
        return constraints, self.planform, self.components

    
class NormalWing(Model):
    """
    Variables
    ---------
    n_prop    1     [-]             number of powertrains/propellers
    m               [kg]            mass
    """
    @parse_variables(__doc__,globals())
    def setup(self):

        self.powertrain = Powertrain()
        N = 14
        self.wing = Wing(N)
        self.wing.substitutions[self.wing.planform.tau]=0.12
        self.wing.substitutions[self.wing.planform.lam]=1
        constraints = [
            m >= self.powertrain["m"] + self.wing.W/2.02462*units('kg/lbf')#("W")/g,
        ]
        return constraints,self.powertrain,self.wing
    def dynamic(self,state,wingmode="na"):
        return NormalWingP(self,state)

class NormalWingP(Model):

    """
    Variables
    ---------
    C_L             [-]             total lift coefficient
    C_Di            [-]             induced drag coefficient
    C_Dp            [-]             profile drag
    C_D             [-]             total drag coefficient
    Re              [-]             Reynolds number
    e       0.8     [-]             span efficiency
    mfac    1.2     [-]             profile drag margin
    Kf      1.180   [-]             form factor
    C_f             [-]             friction coefficient
    CLmax    2.5    [-]             max coefficinet of lift
    T               [N]             propeller thrust
    P               [kW]            power draw
    C_T             [-]             thrust coefficient
    eta_prop        [-]             propeller efficiency
    RPMmax          [rpm]           max RPM of propeller
    r               [m]             propeller radius
    a         343   [m/s]           speed of sound
    Mlim      0.5   [-]             tip Mach limit
    A_disk          [m**2]       area of propeller disk
    """
    @parse_variables(__doc__,globals())
    def setup(self,bw,state):
        #bw is a BlownWing object
        #state is a FlightState

        with gpkit.SignomialsEnabled():
            constraints = [
               bw.powertrain.r>=0.1*units("m"),
               A_disk == bw.n_prop*pi*bw.powertrain.r**2,
               C_L <= CLmax,
               C_Di*(pi*bw.wing["AR"]*e ) >= (C_L**2),
               C_D >= C_Di  + C_Dp,
               C_f**5 == (mfac*0.074)**5 /(Re),
               C_Dp == C_f*2.1*Kf,
               Re == state["V"]*state["rho"]*(bw.wing["S"]/bw.wing["AR"])**0.5/state["mu"],
               
               C_T == T / (0.5 * state.rho * bw.wing["S"] * state.V**2),
               P >= T * state.V / (eta_prop * bw.powertrain.eta),
               bw.powertrain.RPMmax * bw.powertrain.r <= a * Mlim,
               P <= bw.n_prop * bw.powertrain["Pmax"],
               T >= 0.5 * state.rho * bw.wing["S"] * state.V**2 * C_D,
               ]
            
        return constraints
    

class BlownWing(Model):
    """
    Variables
    ---------
    n_prop     10   [-]             number of powertrains/propellers
    m               [kg]            mass
    """
    @parse_variables(__doc__,globals())
    def setup(self,seg="cruise"):
        self.powertrain = Powertrain()
        N = 14
        self.wing = Wing(N)
        self.wing.substitutions[self.wing.planform.tau]=0.12
        self.wing.substitutions[self.wing.planform.lam]=1
        
        constraints = [
            m >= n_prop*self.powertrain["m"] + self.wing.W/2.02462*units('kg/lbf')#("W")/g,
        ]
        return constraints,self.powertrain,self.wing
    def dynamic(self,state,seg =False):
        return BlownWingP(self,state,seg=seg)

class BlownWingP(Model):
    #Built from Mark Drela's Powered-Lift and Drag Calculation
    #and Thin Airfoil Theory for Blown 2D Airfoils notes

    """
    Variables
    ---------
    C_L             [-]             total lift coefficient
    C_LC            [-]             lift coefficient due to circulation
    C_Q             [-]             mass momentum coefficient
    C_J             [-]             jet momentum coefficient
    C_E             [-]             energy momentum coefficient
    C_Di            [-]             induced drag coefficient
    C_Dp            [-]             profile drag
    C_D             [-]             total drag coefficient
    C_T             [-]             thrust coefficient
    Re              [-]             Reynolds number
    e       0.8     [-]             span efficiency
    mfac    1.2     [-]             profile drag margin
    m_dotprime      [kg/(m*s)]      jet mass flow per unit span
    J_prime         [kg/(s**2)]     momentum flow per unit span
    E_prime         [J/(m*s)]       energy flow per unit span
    rho_j   1.225   [kg/m**3]       density in jet flow
    u_j             [m/s]           velocity in jet flow
    h               [m]             Wake height
    T               [N]             propeller thrust
    P               [kW]            power draw
    eta_prop        [-]             prop efficiency loss after blade disk actuator
    A_disk          [m**2]          area of prop disk
    Mlim      0.5   [-]             tip limit
    a         343   [m/s]           speed of sound at sea level
    RPMmax          [rpm]           maximum rpm of propeller
    Kf        1.180 [-]             form factor
    C_f             [-]             friction coefficient
    CLCmax    3.5   [-]             clc max
    """
    @parse_variables(__doc__,globals())
    def setup(self,bw,state,seg):
        #bw is a BlownWing object
        #state is a FlightState
        n_active = 2 if seg else bw["n_prop"]
        with gpkit.SignomialsEnabled():
            constraints = [
            A_disk == n_active*pi*bw.powertrain.r**2,
            ((P*eta_prop*bw.powertrain.eta)/(0.5*T*state["V"]) - 1)**2 >= (T/(A_disk*(state.V**2)*state.rho/2)+1),
            (u_j/state.V)**2 <= (T/(A_disk*(state.V**2)*state.rho/2) + 1),
            u_j >= state.V,
            P <= n_active*bw.powertrain["Pmax"],

            C_L <= C_LC*(1+2*C_J/(pi*bw.wing["AR"]*e)),
            C_L >= C_LC,
            C_LC <= CLCmax,
            bw.powertrain.RPMmax*bw.powertrain.r <= a*Mlim,
            C_T == T/((0.5*state.rho*bw.wing["S"]*state.V**2)),
            m_dotprime == rho_j*u_j*h,
            J_prime ==  m_dotprime*u_j,
            E_prime == 0.5*m_dotprime*u_j**2,
            C_Q ==  m_dotprime/(state.rho*state.V* bw.wing["cmac"]),
            C_J == J_prime/(0.5*state.rho*state.V**2 * bw.wing["cmac"]),
            C_E == E_prime/(0.5*state.rho*state.V**3 * bw.wing["cmac"]),
            h == pi*bw.powertrain.r/2,
            C_Di*(pi*bw.wing["AR"]*e + 2*C_J) >= (C_L**2),
            C_D >= C_Di  + C_Dp,
            C_f**5 == (mfac*0.074)**5 /(Re),
            C_Dp == C_f*2.1*Kf,
            Re == state["V"]*state["rho"]*(bw.wing["S"]/bw.wing["AR"])**0.5/state["mu"],
            ]
        return constraints
from gpkit import Model, parse_variables 
class Gear(Model):
    """Gear
    Variables
    ---------
    m         [lb]    total landing gear mass
    l         [ft]    landing gear length
    """
    @parse_variables(__doc__,globals())
    def setup(self):

        return []

class Equipment(Model):
    """Equipment
    Variables
    ---------
    m             [lb]       total equipment mass, without battery
    """
    @parse_variables(__doc__,globals())
    def setup(self):

        return []

class Fuselage(Model):
    """ Fuselage

    Variables
    ---------
    m                    [lb]    mass of fuselage
    l       24.26        [ft]    fuselage length
    w       5.67         [ft]    width
    h       8.57         [ft]    fuselage height
    f                    [-]     fineness ratio
    Swet                 [ft^2]  wetted area of fuselage
    """
    @parse_variables(__doc__,globals())
    def setup(self):

        return [
                f == l/h,
                Swet >=2.1*(l*w+l*h),# Raymer’s approximation for wetted area
                ]
    def dynamic(self,state):
        return FuselageP(self,state)

class FuselageP(Model):
    """FuselageP
    Variables
    ---------
    Cd              [-]     drag coefficient
    FF              [-]     form factor
    C_f             [-]     friction coefficient
    mfac     1.2    [-]     friction margin
    Re              [-]     Reynolds number
    """
    @parse_variables(__doc__,globals())
    def setup(self,fuse,state):
        constraints = [
                       FF ==fuse.l/fuse.h,
                       C_f >= 0.455/Re**0.3,
                       Cd/mfac == C_f*FF,
                       Re == state["V"]*state["rho"]*fuse.l/state["mu"],
                    ]
        return constraints
import gpkit
from gpkit import Model, parse_variables, Vectorize, SignomialEquality,Variable,units
from fusegear import *
from battm import *
from wing import *
from tail import *
import math
import numpy as np

class Aircraft(Model):
    """ Aircraft

    Variables
    ---------
    mass               [kg]    aircraft mass 
    n_pax       2       [-]     number of passengers
    mpax        86      [kg]    single passenger mass
    mbaggage    10       [kg]    single baggage mass
    tangamma    0.5     [-]     tan of the gamma climb angle
    d                   [in]    spar diam
    """
    @parse_variables(__doc__,globals())
    def setup(self,wingmode):
        self.equipment = Equipment()
        self.battery = Battery()
        self.fuselage = Fuselage()
        self.htail = HorizontalTail()
        self.vtail = VerticalTail()
        self.boom =  TailBoom()
        self.gear = Gear()
        self.vtail.substitutions[self.vtail.planform.tau] = 0.08
        self.htail.substitutions[self.htail.planform.tau] = 0.08
        self.htail.substitutions[self.htail.mh] = 0.8
        self.htail.substitutions[self.vtail.Vv] = 0.1
        self.htail.substitutions[self.htail.planform.CLmax] = 3
        self.vtail.substitutions[self.vtail.planform.CLmax] = 3
        
        if wingmode =="na":
         self.bw = NormalWing()
        elif wingmode =="blownwing":
         self.bw = BlownWing()
        else: print("choose between  na or blownwing , invalid input")

        self.components = [self.bw,self.fuselage,self.gear,self.equipment,self.battery]

        constraints = [

                       self.htail.Vh == (self.htail["S"]*self.htail.lh/self.bw.wing["S"]**2 *self.bw.wing["b"]),
                       self.vtail.Vv == (self.vtail["S"]*self.vtail.lv/self.bw.wing["S"]/self.bw.wing["b"]),
                       
                       self.boom["l"] >= self.htail.lh + self.htail.planform.croot,
                       self.boom["l"] >= self.vtail.lv + self.vtail.planform.croot,

                       self.fuselage.m >= 0.14*(sum(c.m for c in self.components) + (self.boom.W + self.vtail.W + self.htail.W)/2.20462*units('kg/lbf') + (mpax+mbaggage)*n_pax),
                       self.mass >= sum(c.m for c in self.components) + (self.boom.W + self.vtail.W + self.htail.W)/2.20462*units('kg/lbf') + (mpax+mbaggage)*n_pax,
                       self.gear.m >=0.04*self.mass,
                       self.equipment.m>=0.15*self.mass,
                       self.gear.l==0.16*self.fuselage.l,#Source: Raymer, D. P. – Aircraft Design: A Conceptual Approach (5th Edition), Section on Landing Gear Sizing.
                      # self.mass == 750*units("kg"),
                       #self.mass>= self.battery.m
                       ]
        for s in self.boom.d:
            constraints+=[s == d]
        with gpkit.SignomialsEnabled():
            constraints += [self.boom["l"]*0.36 <= self.gear.l + self.fuselage.h,
                            self.bw.wing.b - Variable("w_fuse",50,"in") >= self.bw.n_prop*2*self.bw.powertrain.r]
        return constraints, self.components, self.htail, self.vtail, self.boom
    
    def dynamic(self,state,groundroll=False,powermode=True,wingmode ="blownwing",seg =False):
        return AircraftP(self,state,groundroll=groundroll,powermode=powermode,wingmode=wingmode,seg=seg)

    def loading(self,state,Wcent,Wh,Wv):
        return AircraftLoading(self,state)
    
class AircraftP(Model):
    """ AircraftP

    Variables
    ---------
    P                   [kW]    total power draw
    CD                  [-]     total CD, referenced to wing area
    P_charge            [kW]    battery charging power
    P_avionics  0.25    [kW]    avionics continuous power draw
    C_chrg              [1/hr]  battery charge rate
    CDfrac              [-]     fuselage drag fraction
    L_D                 [-]     aircraft lift-to-drag ratio
    """
    @parse_variables(__doc__,globals())
    def setup(self,aircraft,state,groundroll=False,powermode=True,wingmode="blownwing",seg=False):
        self.fuse_perf = aircraft.fuselage.dynamic(state)

        self.bw_perf = aircraft.bw.dynamic(state)
        self.batt_perf = aircraft.battery.dynamic(state,powermode)
        self.htail_perf = aircraft.htail.flight_model(aircraft.htail, state)
        self.vtail_perf = aircraft.vtail.flight_model(aircraft.vtail, state)
        self.boom_perf = aircraft.boom.flight_model(aircraft.boom, state)
        self.perf_models = [self.fuse_perf,self.bw_perf,self.batt_perf,self.htail_perf,self.vtail_perf,self.boom_perf]
        self.fs = state

        constraints = [P >= self.bw_perf["P"] + P_avionics,
                       CD >= self.bw_perf.C_D + ((aircraft.htail.planform.S/aircraft.bw.wing.planform.S)*self.htail_perf.Cd + (self.fuse_perf.Cd*aircraft.fuselage.Swet/aircraft.bw.wing.planform.S) + (aircraft.vtail.planform.S/aircraft.bw.wing.planform.S)*self.vtail_perf.Cd) + (aircraft.boom.S/aircraft.bw.wing.planform.S)*self.boom_perf.Cf,
                       CDfrac == (self.fuse_perf.Cd*aircraft.fuselage.Swet/aircraft.bw.wing.planform.S)/CD,
                       L_D == self.bw_perf.C_L/CD,
                       state.V <= state.Vne
                    ]
        if wingmode =="blownwing":
         constraints+=[self.bw_perf.C_T >= CD,]
         if seg ==True:aircraft.bw.substitutions.update({aircraft.bw.n_prop :2})
         else: aircraft.bw.substitutions.update({aircraft.bw.n_prop :10})
        #If we're not in groundroll, apply lift=weight and fuselage drag
        if groundroll == False:
            constraints += [0.5*self.bw_perf.C_L*state.rho*aircraft.bw.wing["S"]*state.V**2 >= aircraft.mass*g]
        constraints += [self.batt_perf.P >= P]
        
        

        return constraints,self.perf_models
    
    
class AircraftLoading(Model):
    
    def setup(self,aircraft,state):
        self.hbend = aircraft.boom.tailLoad(aircraft.boom,aircraft.htail,state)
        self.vbend = aircraft.boom.tailLoad(aircraft.boom,aircraft.vtail,state)
        self.wingl = aircraft.bw.wing.spar.loading(aircraft.bw.wing, state)
        self.hl = aircraft.htail.spar.loading(aircraft.htail, state)
        self.vl = aircraft.vtail.spar.loading(aircraft.vtail, state)
        loading = [self.wingl,self.hbend,self.vbend,self.hl,self.vl]
        
        return loading
import gpkit
from gpkit import Model, parse_variables, Vectorize, SignomialEquality,Variable,units
from aircraft import *


class FlightState(Model):
    """ Flight State

    Variables
    ---------
    rho         1.225       [kg/m**3]       air density
    mu          1.789e-5    [N*s/m^2]       air viscosity
    V                       [kts]           speed
    qne                     [kg/s^2/m]      never exceed dynamic pressure
    Vne         108         [kts]           never exceed speed
    """
    @parse_variables(__doc__,globals())
    def setup(self):
        return [qne == 0.5*rho*Vne**2,]



class Mission(Model):
    """ Mission

    Variables
    ---------
    Srunway                     [m]        runway length
    Sobstacle                   [ft]        obstacle length
    mrunway         1.4         [-]         runway margin
    mobstacle       1.4         [-]         obstacle margin
    R                           [nmi]       mission range
    Vstall          45          [kts]       power off stall requirement
    Vs                          [kts]       power off stall speed
    CLstall         2.5         [-]         power off stall CL
    dV                          [m/s]       dV
    CJmax                       [-]         maximum CJ of mission
    CLmax                       [-]         maximum CL of mission
    t_tot                           [s]         time of flight
    """
    @parse_variables(__doc__,globals())
    def setup(self,perf=False,wingmode="blownwing"):

        self.aircraft = Aircraft(wingmode =wingmode)
        with Vectorize(4):
            self.takeoff = TakeOff(self.aircraft)
        self.obstacle_climb = Climb(self.aircraft)
        self.climb = Climb(self.aircraft,powermode=False,seg=False)
        self.cruise = Cruise(self.aircraft,wingmode= wingmode)
        self.landing = Landing(self.aircraft)
        Wcent = Variable("W_{cent}","lbf","center aircraft weight")
        Wh = Variable("W_{htail}", "lbf", "horizontal tail weight")
        Wv = Variable("W_{vtail}", "lbf", "vertical tail weight")
        loading = self.aircraft.loading(self.cruise.flightstate,Wcent, Wh, Wv)
        self.loading = loading
        S = self.S = self.aircraft.bw.wing["S"]
        
        
        self.fs = [self.takeoff,self.obstacle_climb,self.landing,self.climb,self.cruise,]#self.reserve
        #self.t_tot = sum(s.t for s in self.fs)
        
        state = FlightState()#self.flightstate
        with gpkit.SignomialsEnabled():
            if wingmode =="blownwing":
               constraints=[CJmax >= self.takeoff.perf.bw_perf.C_J,
                             CJmax >= self.landing.perf.bw_perf.C_J,
                             self.aircraft.htail.Vh >= 0.001563*CJmax*CLmax + 0.0323*CLmax + 0.03014*CJmax + 0.5216,
                             self.climb.perf.bw_perf.C_LC == 0.611,
                              
                            CLmax >= self.takeoff.perf.bw_perf.C_L,
                            CLmax >= self.landing.perf.bw_perf.C_L,
                            self.obstacle_climb.h_gain >= 50*units("ft"),
                            self.climb.h_gain >= 2000*units("ft") - self.obstacle_climb.h_gain,
                            self.climb.Sclimb == 10*units("nmi"),
                            0.5*state.rho*CLstall*self.aircraft.bw.wing.planform.S*Vs**2 == self.aircraft.mass*g,
                            Vs <= Vstall,
                            Vs >= 42*units("kts"),
                            Srunway <= 100*units("m"),
                            self.takeoff.dV == self.dV,
                            (self.takeoff.fs.V[-1]/self.takeoff.mstall)**2 >= (2*self.aircraft.mass*g/(self.takeoff.rho*self.takeoff.S*self.takeoff.perf.bw_perf.C_L[-1])),
                            0.5*self.takeoff.perf.bw_perf.C_L[-1]*self.takeoff.perf.fs.rho*S*self.takeoff.fs.V[-1]**2 >= self.aircraft.mass*g,
                            self.takeoff.perf.bw_perf.C_L[0:-1] >= 1e-4,
                            Srunway >= mrunway*sum(self.takeoff.Sto),
                            self.takeoff.dV[0]*0.5*self.takeoff.t[0] == self.takeoff.Sto[0],
                            sum(self.takeoff.dV[:2])*0.5*self.takeoff.t[1] <= self.takeoff.Sto[1],
                            sum(self.takeoff.dV[:3])*0.5*self.takeoff.t[2] <= self.takeoff.Sto[2],
                            sum(self.takeoff.dV[:4])*0.5*self.takeoff.t[3] <= self.takeoff.Sto[3],
                            self.takeoff.fs.V[0] >= sum(self.takeoff.dV[:1]),
                            self.takeoff.fs.V[1] >= sum(self.takeoff.dV[:2]),
                            self.takeoff.fs.V[2] >= sum(self.takeoff.dV[:3]),
                            self.takeoff.fs.V[-1] <=  sum(self.takeoff.dV),
                            Srunway >= self.landing.Sgr*mrunway,
                            Sobstacle <= Srunway + 100*units("ft"),#"obstacle distance"),
                            Sobstacle >= mobstacle*(sum(self.takeoff.Sto)+ self.obstacle_climb.Sclimb),
                            loading.wingl["W"] == Wcent,
                            Wcent >= self.aircraft.mass*g,
                            loading.hl["W"] ==Wcent,#>=self.aircraft.htail.W,# >=1*units("lbf"),
                            self.aircraft.mass<=750*units("kg"),
                            loading.vl["W"] ==Wcent,# >=self.aircraft.vtail.W,
                            self.climb.perf.bw_perf.P <=  self.aircraft.bw.n_prop*self.aircraft.bw.powertrain.P_m_sp_cont*self.aircraft.bw.powertrain.m,
                            self.cruise.perf.bw_perf.P <= self.aircraft.bw.n_prop*self.aircraft.bw.powertrain.P_m_sp_cont*self.aircraft.bw.powertrain.m,
                            #self.aircraft.battery.E_capacity/self.cruise.t>= self.aircraft.bw.n_prop*self.aircraft.bw.powertrain.P_m_sp_cont*self.aircraft.bw.powertrain.m,#energy consumed by 2 prop 
                            #self.R>=30*units("km"),
                            
                        ]
            else:
               constraints=[self.aircraft.htail.Vh >= 0.2*CLmax+0.5,
                                CLmax<=2.5,
                                CLmax >= self.takeoff.perf.bw_perf.C_L,
                                CLmax >= self.landing.perf.bw_perf.C_L,
                                self.obstacle_climb.h_gain >= 50*units("ft"),
                                self.climb.h_gain >= 2000*units("ft") - self.obstacle_climb.h_gain,
                                self.climb.Sclimb == 10*units("nmi"),
                                0.5*state.rho*CLstall*self.aircraft.bw.wing.planform.S*Vs**2 == self.aircraft.mass*g,
                                Vs <= Vstall,
                                Vs >= 42*units("kts"),
                                Srunway <= 1000*units("m"),
                                self.takeoff.dV == self.dV,
                                (self.takeoff.fs.V[-1]/self.takeoff.mstall)**2 >= (2*self.aircraft.mass*g/(self.takeoff.rho*self.takeoff.S*self.takeoff.perf.bw_perf.C_L[-1])),
                                0.5*self.takeoff.perf.bw_perf.C_L[-1]*self.takeoff.perf.fs.rho*S*self.takeoff.fs.V[-1]**2 >= self.aircraft.mass*g,
                                self.takeoff.perf.bw_perf.C_L[0:-1] >= 1e-4,
                                Srunway >= mrunway*sum(self.takeoff.Sto),
                                self.takeoff.dV[0]*0.5*self.takeoff.t[0] == self.takeoff.Sto[0],
                                sum(self.takeoff.dV[:2])*0.5*self.takeoff.t[1] <= self.takeoff.Sto[1],
                                sum(self.takeoff.dV[:3])*0.5*self.takeoff.t[2] <= self.takeoff.Sto[2],
                                sum(self.takeoff.dV[:4])*0.5*self.takeoff.t[3] <= self.takeoff.Sto[3],
                                self.takeoff.fs.V[0] >= sum(self.takeoff.dV[:1]),
                                self.takeoff.fs.V[1] >= sum(self.takeoff.dV[:2]),
                                self.takeoff.fs.V[2] >= sum(self.takeoff.dV[:3]),
                                self.takeoff.fs.V[-1] <=  sum(self.takeoff.dV),
                                Srunway >= self.landing.Sgr*mrunway,
                                Sobstacle <= Srunway + 100*units("ft"),#"obstacle distance"),
                                Sobstacle >= mobstacle*(sum(self.takeoff.Sto)+ self.obstacle_climb.Sclimb),
                                loading.wingl["W"] == Wcent,
                                Wcent >= self.aircraft.mass*g, 
                                self.aircraft.mass<=750*units("kg"),
                                
                                loading.hl["W"] >=self.aircraft.htail.W,# >=1*units("lbf"),

                                loading.vl["W"] >=self.aircraft.vtail.W,#>=1*units("lbf"),
                                self.climb.perf.bw_perf.P <=  self.aircraft.bw.n_prop*self.aircraft.bw.powertrain.P_m_sp_cont*self.aircraft.bw.powertrain.m,
                                self.cruise.perf.bw_perf.P <= self.aircraft.bw.n_prop*self.aircraft.bw.powertrain.P_m_sp_cont*self.aircraft.bw.powertrain.m,
                                #self.aircraft.battery.E_capacity/self.cruise.t>= self.aircraft.bw.n_prop*self.aircraft.bw.powertrain.P_m_sp_cont*self.aircraft.bw.powertrain.m,#energy consumed by 2 prop 
                                #self.R>=30*units("km"),
                                 ]
        if not perf:
            constraints += [self.R >=1*units("nmi"),]#"cruise range minimum")]
        constraints += [self.aircraft.battery.E_capacity*0.8 >= sum(s.t*s.perf.batt_perf.P for s in self.fs),
                        ]
        with gpkit.SignomialsEnabled():
            constraints += [self.R <= self.cruise.R]
        return constraints,self.aircraft,self.fs, loading,

class TakeOff(Model):
    """
    Variables
    ---------
    g           9.81        [m/s**2]    gravitational constant
    mu          0.025       [-]         coefficient of rolling resistance
    T                       [N]         takeoff thrust
    CDg                     [-]         drag ground coefficient
    Sto                     [ft]        takeoff distance
    W                       [N]         aircraft weight
    t                       [s]         takeoff segment time
    dV                      [kt]        takeoff segment velocity difference
    mstall      1.1         [-]         takeoff stall margin
    rho                     [kg/m^3]    air density
    S                       [m^2]       wing area
    a                       [m/s/s]     takeoff segment acceleration
    """
    @parse_variables(__doc__,globals())
    def setup(self, aircraft,N=5):
        self.fs = FlightState()
        Pmax = aircraft.bw.powertrain.Pmax
        AR = aircraft.bw.wing.planform.AR
        perf = aircraft.dynamic(self.fs,groundroll=True)
        self.perf = perf
        e = perf.bw_perf.e
        with gpkit.SignomialsEnabled():
            constraints = [
                rho == self.fs.rho,
                S == aircraft.bw.wing["S"],
                W == aircraft.mass*g,
                self.perf.bw_perf.eta_prop == 0.75,
                CDg == perf.bw_perf.C_D,
                (T-0.5*CDg*rho*S*self.fs.V**2)/aircraft.mass >= a,
                t*a == dV,
                T <= perf.bw_perf.T
                ]


        return constraints, self.fs, perf

class Climb(Model):

    """ Climb model

    Variables
    ---------
    Sclimb                  [ft]        distance covered in climb
    h_gain                  [ft]        height gained in climb
    t                       [s]         time of climb
    h_dot                   [m/s]       climb rate
    W                       [N]         aircraft weight

    LaTex Strings
    -------------
    Sclimb      S_{\\mathrm{climb}}
    h_gain      h_{\\mathrm{gain}}
    h_dot       \\dot{h}
    """
    @parse_variables(__doc__,globals())
    def setup(self,aircraft,powermode=True,seg= False):

        self.flightstate = FlightState()
        perf = aircraft.dynamic(self.flightstate,powermode=powermode,seg = seg)
        self.perf = perf
        CL = self.CL = perf.bw_perf.C_L
        S = self.S = aircraft.bw.wing["S"]
        CD = self.CD = perf.CD
        V = perf.fs.V
        rho = perf.fs.rho

        constraints = [
            perf.batt_perf.P <= aircraft.battery.m*aircraft.battery.P_max_cont*aircraft.battery.eta_pack,
            perf.bw_perf.eta_prop == 0.87,
            W ==  aircraft.mass*g,
            perf.bw_perf.C_T*rho*S*V**2 >= 0.5*CD*rho*S*V**2 + W*h_dot/V,
            self.h_gain <= h_dot*t,
            Sclimb == V*t, 
            self.flightstate #sketchy constraint, is wrong with cos(climb angle)
        ]
        return constraints, perf

class Cruise(Model):
    """

    Variables
    ---------
    R           [nmi]       cruise range
    t           [min]       cruise time
    Vmin  98    [kts]       cruise minimum speed
    """
    @parse_variables(__doc__,globals())
    def setup(self,aircraft,wingmode):

        self.flightstate = FlightState()
        self.perf = aircraft.dynamic(self.flightstate,powermode =False,seg =True)
        constraints = [R <= t*self.flightstate.V, # speed *t is distance 
                       self.flightstate["V"] >= Vmin,
                       self.perf.bw_perf.eta_prop == 0.87,
                       ]
        if wingmode=="blownwing":
            constraints +=[self.perf.bw_perf.C_LC == 0.534,]

        return constraints, self.flightstate, self.perf
    
class Landing(Model):
    """ landing model

    Variables
    ---------
    g           9.81        [m/s**2]    gravitational constant
    h_obst      50          [ft]        obstacle height
    Xgr                     [ft]        landing ground roll
    Xa                      [ft]        approach distance
    Xro                     [ft]        round out distance
    Xdec                    [ft]        deceleration distance
    tang        -0.0524     [-]         tan(gamma)
    cosg        0.9986      [-]         cos(gamma)
    sing        -0.0523     [-]         sin(gamma)
    h_r                     [ft]        height of roundout
    T_a                     [N]         approach thrust
    W                       [N]         aircraft weight
    r                       [ft]        radius of roundout maneuver
    Vs                      [kts]       stall velocity
    nz           1.25       [-]         load factor
    Xla                     [ft]        total landing distance
    mu_b         0.6        [-]         braking friction coefficient
    Sgr                     [ft]        landing distance
    mstall       1.2        [-]         landing stall margin
    t                       [s]         time of landing maneuver
    """
    @parse_variables(__doc__,globals())
    def setup(self, aircraft,powermode =True):


        fs = FlightState()

        S = self.S = aircraft.bw.wing["S"]
        rho = fs.rho
        perf = aircraft.dynamic(fs,powermode='tol')
        CL = perf.bw_perf.C_L
        CD = perf.bw_perf.C_D
        V = perf.fs.V
        rho = perf.fs.rho
        C_T = perf.bw_perf.C_T
        self.perf = perf
        with gpkit.SignomialsEnabled():
            constraints = [
                # perf.bw_perf.C_LC == 2.19,
                W == aircraft.mass*g,
                C_T >= CD, #+ (W*sing)/(0.5*rho*S*V**2),
                V == Vs*mstall,
                (Vs*mstall)**2  >= (2.*aircraft.mass*g/rho/S/CL),
                Xgr*(2*g*(mu_b)) >= (mstall*Vs)**2,
                Xla >= Xgr,
                Sgr >= Xla,
                t >= Sgr/(0.3*V),
                perf.bw_perf.eta_prop == 0.75,

            ]

        return constraints, fs,perf
'''
def RegularSolve():
    poweredwheels = False
    M = Mission(wingmode ='na')
   # M.substitutions.update({M.aircraft.bw.wing.planform.S:134.22})
   # M.substitutions.update({M.aircraft.bw.wing.planform.AR:8.79})
   # M.substitutions.update({M.aircraft.bw.wing.planform.b:34.34})
   # M.substitutions.update({M.aircraft.mass:500})
    M.cost =M.aircraft.mass
#    M.debug()
    sol = M.localsolve(solver='cvxopt')
    # print M.program.gps[-1].result.summary()
    # print sol.summary()
    #sd = get_highestsens(M, sol, N=10)
   # f, a = plot_chart(sd)
   # f.savefig("sensbar.pdf", bbox_inches="tight")
    print (sol(M.R))
    print (sol(M.aircraft.mass))

def MassCurves():
       M = Mission("na")
       range_sweep = np.linspace(10,1000,5)
       M.substitutions.update({M.Srunway:('sweep',range_sweep)})
       M.cost = M.aircraft.mass
       sol = M.localsolve(solver='cvxopt',skipsweepfailures=True)
       print( sol(M.CLmax))
       plt.plot(sol(M.Srunway),sol(M.aircraft.mass))
       M = Mission("blownwing") 
       M.substitutions.update({M.Srunway:('sweep',range_sweep)})
       M.cost = M.aircraft.mass
       sol = M.localsolve(solver='cvxopt',skipsweepfailures=True)
       print( sol(M.CLmax))
       plt.plot(sol(M.Srunway),sol(M.aircraft.mass))


       plt.show() 
       plt.grid()
       # plt.xlim([0,300])
       # plt.ylim([0,1600])
       plt.title("Impact of Runway length on mass")
       plt.xlabel("Runway Length")
       plt.ylabel("mass")
       # plt.legend()
       plt.show() 
if __name__ == "__main__":
    #Runway()
    #RangeRunway()
   RegularSolve()
   #MassCurves()
'''from gpkitmodels import g

def writeSolNW(sol):
    with open('solveNW.txt', 'w') as output:
        output.write(sol.table())

def writeWgtNW(sol,M):

        # output.write(str('{:10.4f}'.format(float(sol(M.aircraft.mass).magnitude))) + '\n')

        m_tot   = sol(M.aircraft.mass       )
        m_wing  = sol(M.aircraft.bw.wing.W/g).to("kg")
        m_htail = sol(M.aircraft.htail.W/g  ).to("kg")
        m_vtail = sol(M.aircraft.vtail.W/g  ).to("kg")
        m_boom  = sol(M.aircraft.boom.W/g   ).to("kg")
        m_fuse  = sol(M.aircraft.fuselage.m ).to("kg")
        m_equip = sol(M.aircraft.equipment.m).to("kg")
        m_gear  = sol(M.aircraft.gear.m     ).to("kg")
        m_batt  = sol(M.aircraft.battery.m  )
        m_mot   = sol(M.aircraft.bw.powertrain.m     )
        m_pax   = sol(M.aircraft.mpax       )
        m_bag   = sol(M.aircraft.mbaggage   )
        n_prop  = sol(M.aircraft.bw.n_prop  )
        n_pax   = sol(M.aircraft.n_pax      )
        m_mot_tot = n_prop * m_mot
        m_pax_tot = n_pax  * m_pax
        m_bag_tot = n_pax  * m_bag

        output  = open('weightsNW.csv','w')

        output.write(str(m_tot  .magnitude) + '\n')
        output.write(str(m_wing .magnitude) + '\n')
        output.write(str(m_htail.magnitude) + '\n')
        output.write(str(m_vtail.magnitude) + '\n')
        output.write(str(m_boom .magnitude) + '\n')
        output.write(str(m_fuse .magnitude) + '\n')
        output.write(str(m_equip.magnitude) + '\n')
        output.write(str(m_gear .magnitude) + '\n')
        output.write(str(m_batt .magnitude) + '\n')
        output.write(str(m_mot_tot.magnitude) + '\n')
        output.write(str(m_pax_tot.magnitude) + '\n')
        output.write(str(m_bag_tot.magnitude) + '\n')

        output.close

        output  = open('weightsNW.txt','w')

        output.write('Mass Summary\n')
        output.write('individual motor and passenger-related masses shown\n\n')
        output.write('m_tot   = ' + str(m_tot  ) + '\n')
        output.write('m_wing  = ' + str(m_wing ) + '\n')
        output.write('m_htail = ' + str(m_htail) + '\n')
        output.write('m_vtail = ' + str(m_vtail) + '\n')
        output.write('m_boom  = ' + str(m_boom ) + '\n')
        output.write('m_fuse  = ' + str(m_fuse ) + '\n')
        output.write('m_equip = ' + str(m_equip) + '\n')
        output.write('m_gear  = ' + str(m_gear ) + '\n')
        output.write('m_batt  = ' + str(m_batt ) + '\n')
        output.write('m_mot   = ' + str(m_mot  ) + '\n')
        output.write('m_pax   = ' + str(m_pax  ) + '\n')
        output.write('m_bag   = ' + str(m_bag  ) + '\n')
        output.write('n_prop  = ' + str(n_prop ) + ' [-]' + '\n')
        output.write('n_pax   = ' + str(n_pax  ) + ' [-]' + '\n')

        output.close

def writePropNW(sol,M):

        output  = open('propNW.txt','w')

        A_str = '{:5.3f}'
        T_str = '{:9.0f}'
        U_str = '{:7.2f}'
        R_str = '{:7.0f}'
        t_str = '{:7.2f}'

        A_disk = sol(M.cruise.perf.bw_perf.A_disk).magnitude

        T_TO1 = sol(M.takeoff.perf.bw_perf.T[0]    ).magnitude
        T_TO2 = sol(M.takeoff.perf.bw_perf.T[1]    ).magnitude
        T_TO3 = sol(M.takeoff.perf.bw_perf.T[2]    ).magnitude
        T_TO4 = sol(M.takeoff.perf.bw_perf.T[3]    ).magnitude
        T_CL1 = sol(M.obstacle_climb.perf.bw_perf.T).magnitude
        T_CL2 = sol(M.climb.perf.bw_perf.T         ).magnitude
        T_CR  = sol(M.cruise.perf.bw_perf.T        ).magnitude
        T_L   = sol(M.landing.perf.bw_perf.T       ).magnitude

        U_TO1 = sol(M.takeoff.perf.fs.V[0]    ).to("m/s").magnitude
        U_TO2 = sol(M.takeoff.perf.fs.V[1]    ).to("m/s").magnitude
        U_TO3 = sol(M.takeoff.perf.fs.V[2]    ).to("m/s").magnitude
        U_TO4 = sol(M.takeoff.perf.fs.V[3]    ).to("m/s").magnitude
        U_CL1 = sol(M.obstacle_climb.perf.fs.V).to("m/s").magnitude
        U_CL2 = sol(M.climb.perf.fs.V         ).to("m/s").magnitude
        U_CR  = sol(M.cruise.perf.fs.V        ).to("m/s").magnitude
        U_L   = sol(M.landing.perf.fs.V       ).to("m/s").magnitude

       
        V_TO1 = sol(M.takeoff.perf.fs.V[0]    ).to("kts").magnitude
        V_TO2 = sol(M.takeoff.perf.fs.V[1]    ).to("kts").magnitude
        V_TO3 = sol(M.takeoff.perf.fs.V[2]    ).to("kts").magnitude
        V_TO4 = sol(M.takeoff.perf.fs.V[3]    ).to("kts").magnitude
        V_CL1 = sol(M.obstacle_climb.perf.fs.V).to("kts").magnitude
        V_CL2 = sol(M.climb.perf.fs.V         ).to("kts").magnitude
        V_CR  = sol(M.cruise.perf.fs.V        ).to("kts").magnitude
        V_L   = sol(M.landing.perf.fs.V       ).to("kts").magnitude

        D_TO1 = sol(M.takeoff.Sto[0]          ).to("ft").magnitude
        D_TO2 = sol(M.takeoff.Sto[1]          ).to("ft").magnitude
        D_TO3 = sol(M.takeoff.Sto[2]          ).to("ft").magnitude
        D_TO4 = sol(M.takeoff.Sto[3]          ).to("ft").magnitude
        D_CL1 = sol(M.obstacle_climb.Sclimb   ).to("ft").magnitude
        D_CL2 = sol(M.climb.Sclimb            ).to("ft").magnitude
        D_CR  = sol(M.cruise.R                ).to("ft").magnitude
        D_L   = sol(M.landing.Sgr             ).to("ft").magnitude

        s_TO1 = sol(M.takeoff.t[0]            ).to("s").magnitude
        s_TO2 = sol(M.takeoff.t[1]            ).to("s").magnitude
        s_TO3 = sol(M.takeoff.t[2]            ).to("s").magnitude
        s_TO4 = sol(M.takeoff.t[3]            ).to("s").magnitude
        s_CL1 = sol(M.obstacle_climb.t        ).to("s").magnitude
        s_CL2 = sol(M.climb.t                 ).to("s").magnitude
        s_CR  = sol(M.cruise.t                ).to("s").magnitude
        s_L   = sol(M.landing.t               ).to("s").magnitude
    

        R_TO1 =         D_TO1
        R_TO2 = R_TO1 + D_TO2
        R_TO3 = R_TO2 + D_TO3
        R_TO4 = R_TO3 + D_TO4
        R_CL1 = R_TO4 + D_CL1
        R_CL2 = R_CL1 + D_CL2
        R_CR  = R_CL2 + D_CR
        R_L   = R_CR  + D_L
      #  R_R   =         D_R

        t_TO1 =         s_TO1
        t_TO2 = t_TO1 + s_TO2
        t_TO3 = t_TO2 + s_TO3
        t_TO4 = t_TO3 + s_TO4
        t_CL1 = t_TO4 + s_CL1
        t_CL2 = t_CL1 + s_CL2
        t_CR  = t_CL2 + s_CR
        t_L   = t_CR  + s_L
    #    t_R   =         s_R

        output.write('A_disk = ' + str(A_str.format(float(A_disk))) + ' m^2' + '\n\n')

        output.write('       T_tot [N]  V [m/s]  V [kt]   R [ft]   t [s] R_tot [ft] t_tot [s]')
        output.write('\n' + 'TO1 = ' + str(T_str.format(float(T_TO1)))
                          + '  '     + str(U_str.format(float(U_TO1)))
                          + '  '     + str(U_str.format(float(V_TO1)))
                          + '  '     + str(R_str.format(float(D_TO1)))
                          + '  '     + str(t_str.format(float(s_TO1)))
                          + '  '     + str(R_str.format(float(R_TO1)))
                          + '  '     + str(t_str.format(float(t_TO1))))
        output.write('\n' + 'TO2 = ' + str(T_str.format(float(T_TO2)))
                          + '  '     + str(U_str.format(float(U_TO2)))
                          + '  '     + str(U_str.format(float(V_TO2)))
                          + '  '     + str(R_str.format(float(D_TO2)))
                          + '  '     + str(t_str.format(float(s_TO2)))
                          + '  '     + str(R_str.format(float(R_TO2)))
                          + '  '     + str(t_str.format(float(t_TO2))))
        output.write('\n' + 'TO3 = ' + str(T_str.format(float(T_TO3)))
                          + '  '     + str(U_str.format(float(U_TO3)))
                          + '  '     + str(U_str.format(float(V_TO3)))
                          + '  '     + str(R_str.format(float(D_TO3)))
                          + '  '     + str(t_str.format(float(s_TO3)))
                          + '  '     + str(R_str.format(float(R_TO3)))
                          + '  '     + str(t_str.format(float(t_TO3))))
        output.write('\n' + 'TO4 = ' + str(T_str.format(float(T_TO4)))
                          + '  '     + str(U_str.format(float(U_TO4)))
                          + '  '     + str(U_str.format(float(V_TO4)))
                          + '  '     + str(R_str.format(float(D_TO4)))
                          + '  '     + str(t_str.format(float(s_TO4)))
                          + '  '     + str(R_str.format(float(R_TO4)))
                          + '  '     + str(t_str.format(float(t_TO4))))
        output.write('\n' + 'CL1 = ' + str(T_str.format(float(T_CL1)))
                          + '  '     + str(U_str.format(float(U_CL1)))
                          + '  '     + str(U_str.format(float(V_CL1)))
                          + '  '     + str(R_str.format(float(D_CL1)))
                          + '  '     + str(t_str.format(float(s_CL1)))
                          + '  '     + str(R_str.format(float(R_CL1)))
                          + '  '     + str(t_str.format(float(t_CL1))))
        output.write('\n' + 'CL2 = ' + str(T_str.format(float(T_CL2)))
                          + '  '     + str(U_str.format(float(U_CL2)))
                          + '  '     + str(U_str.format(float(V_CL2)))
                          + '  '     + str(R_str.format(float(D_CL2)))
                          + '  '     + str(t_str.format(float(s_CL2)))
                          + '  '     + str(R_str.format(float(R_CL2)))
                          + '  '     + str(t_str.format(float(t_CL2))))
        output.write('\n' + 'CR  = ' + str(T_str.format(float(T_CR )))
                          + '  '     + str(U_str.format(float(U_CR )))
                          + '  '     + str(U_str.format(float(V_CR )))
                          + '  '     + str(R_str.format(float(D_CR )))
                          + '  '     + str(t_str.format(float(s_CR )))
                          + '  '     + str(R_str.format(float(R_CR )))
                          + '  '     + str(t_str.format(float(t_CR ))))
        output.write('\n' + 'L   = ' + str(T_str.format(float(T_L  )))
                          + '  '     + str(U_str.format(float(U_L  )))
                          + '  '     + str(U_str.format(float(V_L  )))
                          + '  '     + str(R_str.format(float(D_L  )))
                          + '  '     + str(t_str.format(float(s_L  )))
                          + '  '     + str(R_str.format(float(R_L  )))
                          + '  '     + str(t_str.format(float(t_L  ))))
        output.write('\n')
#      )

        output.close
def writeSolBW(sol):
    with open('solveBW.txt', 'w') as output:
        output.write(sol.table())

def writeWgtBW(sol,M):

        # output.write(str('{:10.4f}'.format(float(sol(M.aircraft.mass).magnitude))) + '\n')

        m_tot   = sol(M.aircraft.mass       )
        m_wing  = sol(M.aircraft.bw.wing.W/g).to("kg")
        m_htail = sol(M.aircraft.htail.W/g  ).to("kg")
        m_vtail = sol(M.aircraft.vtail.W/g  ).to("kg")
        m_boom  = sol(M.aircraft.boom.W/g   ).to("kg")
        m_fuse  = sol(M.aircraft.fuselage.m ).to("kg")
        m_equip = sol(M.aircraft.equipment.m).to("kg")
        m_gear  = sol(M.aircraft.gear.m     ).to("kg")
        m_batt  = sol(M.aircraft.battery.m  )
        m_mot   = sol(M.aircraft.bw.powertrain.m     )
        m_pax   = sol(M.aircraft.mpax       )
        m_bag   = sol(M.aircraft.mbaggage   )
        n_prop  = sol(M.aircraft.bw.n_prop  )
        n_pax   = sol(M.aircraft.n_pax      )
        m_mot_tot = n_prop * m_mot
        m_pax_tot = n_pax  * m_pax
        m_bag_tot = n_pax  * m_bag

        output  = open('weightsBW.csv','w')

        output.write(str(m_tot  .magnitude) + '\n')
        output.write(str(m_wing .magnitude) + '\n')
        output.write(str(m_htail.magnitude) + '\n')
        output.write(str(m_vtail.magnitude) + '\n')
        output.write(str(m_boom .magnitude) + '\n')
        output.write(str(m_fuse .magnitude) + '\n')
        output.write(str(m_equip.magnitude) + '\n')
        output.write(str(m_gear .magnitude) + '\n')
        output.write(str(m_batt .magnitude) + '\n')
        output.write(str(m_mot_tot.magnitude) + '\n')
        output.write(str(m_pax_tot.magnitude) + '\n')
        output.write(str(m_bag_tot.magnitude) + '\n')

        output.close

        output  = open('weightsBW.txt','w')

        output.write('Mass Summary\n')
        output.write('individual motor and passenger-related masses shown\n\n')
        output.write('m_tot   = ' + str(m_tot  ) + '\n')
        output.write('m_wing  = ' + str(m_wing ) + '\n')
        output.write('m_htail = ' + str(m_htail) + '\n')
        output.write('m_vtail = ' + str(m_vtail) + '\n')
        output.write('m_boom  = ' + str(m_boom ) + '\n')
        output.write('m_fuse  = ' + str(m_fuse ) + '\n')
        output.write('m_equip = ' + str(m_equip) + '\n')
        output.write('m_gear  = ' + str(m_gear ) + '\n')
        output.write('m_batt  = ' + str(m_batt ) + '\n')
        output.write('m_mot   = ' + str(m_mot  ) + '\n')
        output.write('m_pax   = ' + str(m_pax  ) + '\n')
        output.write('m_bag   = ' + str(m_bag  ) + '\n')
        output.write('n_prop  = ' + str(n_prop ) + ' [-]' + '\n')
        output.write('n_pax   = ' + str(n_pax  ) + ' [-]' + '\n')

        output.close
def writePropBW(sol,M):

           output  = open('propBW.txt','w')

           A_str = '{:5.3f}'
           T_str = '{:9.0f}'
           U_str = '{:7.2f}'
           R_str = '{:7.0f}'
           t_str = '{:7.2f}'

           A_disk = sol(M.cruise.perf.bw_perf.A_disk).magnitude

           T_TO1 = sol(M.takeoff.perf.bw_perf.T[0]    ).magnitude
           T_TO2 = sol(M.takeoff.perf.bw_perf.T[1]    ).magnitude
           T_TO3 = sol(M.takeoff.perf.bw_perf.T[2]    ).magnitude
           T_TO4 = sol(M.takeoff.perf.bw_perf.T[3]    ).magnitude
           T_CL1 = sol(M.obstacle_climb.perf.bw_perf.T).magnitude
           T_CL2 = sol(M.climb.perf.bw_perf.T         ).magnitude
           T_CR  = sol(M.cruise.perf.bw_perf.T        ).magnitude
           T_L   = sol(M.landing.perf.bw_perf.T       ).magnitude
          # T_R   = sol(M.reserve.perf.bw_perf.T       ).magnitude

           U_TO1 = sol(M.takeoff.perf.fs.V[0]    ).to("m/s").magnitude
           U_TO2 = sol(M.takeoff.perf.fs.V[1]    ).to("m/s").magnitude
           U_TO3 = sol(M.takeoff.perf.fs.V[2]    ).to("m/s").magnitude
           U_TO4 = sol(M.takeoff.perf.fs.V[3]    ).to("m/s").magnitude
           U_CL1 = sol(M.obstacle_climb.perf.fs.V).to("m/s").magnitude
           U_CL2 = sol(M.climb.perf.fs.V         ).to("m/s").magnitude
           U_CR  = sol(M.cruise.perf.fs.V        ).to("m/s").magnitude
           U_L   = sol(M.landing.perf.fs.V       ).to("m/s").magnitude
          # U_R   = sol(M.reserve.perf.fs.V       ).to("m/s").magnitude

           u_j_TO1 = sol(M.takeoff.perf.bw_perf.u_j[0]    ).to("m/s").magnitude
           u_j_TO2 = sol(M.takeoff.perf.bw_perf.u_j[1]    ).to("m/s").magnitude
           u_j_TO3 = sol(M.takeoff.perf.bw_perf.u_j[2]    ).to("m/s").magnitude
           u_j_TO4 = sol(M.takeoff.perf.bw_perf.u_j[3]    ).to("m/s").magnitude
           u_j_CL1 = sol(M.obstacle_climb.perf.bw_perf.u_j).to("m/s").magnitude
           u_j_CL2 = sol(M.climb.perf.bw_perf.u_j         ).to("m/s").magnitude
           u_j_CR  = sol(M.cruise.perf.bw_perf.u_j        ).to("m/s").magnitude
           u_j_L   = sol(M.landing.perf.bw_perf.u_j       ).to("m/s").magnitude
        #   u_j_R   = sol(M.reserve.perf.bw_perf.u_j       ).to("m/s").magnitude

           V_TO1 = sol(M.takeoff.perf.fs.V[0]    ).to("kts").magnitude
           V_TO2 = sol(M.takeoff.perf.fs.V[1]    ).to("kts").magnitude
           V_TO3 = sol(M.takeoff.perf.fs.V[2]    ).to("kts").magnitude
           V_TO4 = sol(M.takeoff.perf.fs.V[3]    ).to("kts").magnitude
           V_CL1 = sol(M.obstacle_climb.perf.fs.V).to("kts").magnitude
           V_CL2 = sol(M.climb.perf.fs.V         ).to("kts").magnitude
           V_CR  = sol(M.cruise.perf.fs.V        ).to("kts").magnitude
           V_L   = sol(M.landing.perf.fs.V       ).to("kts").magnitude
      #     V_R   = sol(M.reserve.perf.fs.V       ).to("kts").magnitude

           D_TO1 = sol(M.takeoff.Sto[0]          ).to("ft").magnitude
           D_TO2 = sol(M.takeoff.Sto[1]          ).to("ft").magnitude
           D_TO3 = sol(M.takeoff.Sto[2]          ).to("ft").magnitude
           D_TO4 = sol(M.takeoff.Sto[3]          ).to("ft").magnitude
           D_CL1 = sol(M.obstacle_climb.Sclimb   ).to("ft").magnitude
           D_CL2 = sol(M.climb.Sclimb            ).to("ft").magnitude
           D_CR  = sol(M.cruise.R                ).to("ft").magnitude
           D_L   = sol(M.landing.Sgr             ).to("ft").magnitude
         #  D_R   = sol(M.reserve.R               ).to("ft").magnitude

           s_TO1 = sol(M.takeoff.t[0]            ).to("s").magnitude
           s_TO2 = sol(M.takeoff.t[1]            ).to("s").magnitude
           s_TO3 = sol(M.takeoff.t[2]            ).to("s").magnitude
           s_TO4 = sol(M.takeoff.t[3]            ).to("s").magnitude
           s_CL1 = sol(M.obstacle_climb.t        ).to("s").magnitude
           s_CL2 = sol(M.climb.t                 ).to("s").magnitude
           s_CR  = sol(M.cruise.t                ).to("s").magnitude
           s_L   = sol(M.landing.t               ).to("s").magnitude
         #  s_R   = sol(M.reserve.t               ).to("s").magnitude

           R_TO1 =         D_TO1
           R_TO2 = R_TO1 + D_TO2
           R_TO3 = R_TO2 + D_TO3
           R_TO4 = R_TO3 + D_TO4
           R_CL1 = R_TO4 + D_CL1
           R_CL2 = R_CL1 + D_CL2
           R_CR  = R_CL2 + D_CR
           R_L   = R_CR  + D_L
         #  R_R   =         D_R

           t_TO1 =         s_TO1
           t_TO2 = t_TO1 + s_TO2
           t_TO3 = t_TO2 + s_TO3
           t_TO4 = t_TO3 + s_TO4
           t_CL1 = t_TO4 + s_CL1
           t_CL2 = t_CL1 + s_CL2
           t_CR  = t_CL2 + s_CR
           t_L   = t_CR  + s_L
       #    t_R   =         s_R

           output.write('A_disk = ' + str(A_str.format(float(A_disk))) + ' m^2' + '\n\n')

           output.write('       T_tot [N]  V [m/s]  uj [m/s]  V [kt]   R [ft]   t [s] R_tot [ft] t_tot [s]')
           output.write('\n' + 'TO1 = ' + str(T_str.format(float(T_TO1)))
                             + '  '     + str(U_str.format(float(U_TO1)))
                             + '  '     + str(U_str.format(float(u_j_TO1)))
                             + '  '     + str(U_str.format(float(V_TO1)))
                             + '  '     + str(R_str.format(float(D_TO1)))
                             + '  '     + str(t_str.format(float(s_TO1)))
                             + '  '     + str(R_str.format(float(R_TO1)))
                             + '  '     + str(t_str.format(float(t_TO1))))
           output.write('\n' + 'TO2 = ' + str(T_str.format(float(T_TO2)))
                             + '  '     + str(U_str.format(float(U_TO2)))
                             + '  '     + str(U_str.format(float(u_j_TO2)))
                             + '  '     + str(U_str.format(float(V_TO2)))
                             + '  '     + str(R_str.format(float(D_TO2)))
                             + '  '     + str(t_str.format(float(s_TO2)))
                             + '  '     + str(R_str.format(float(R_TO2)))
                             + '  '     + str(t_str.format(float(t_TO2))))
           output.write('\n' + 'TO3 = ' + str(T_str.format(float(T_TO3)))
                             + '  '     + str(U_str.format(float(U_TO3)))
                             + '  '     + str(U_str.format(float(u_j_TO3)))
                             + '  '     + str(U_str.format(float(V_TO3)))
                             + '  '     + str(R_str.format(float(D_TO3)))
                             + '  '     + str(t_str.format(float(s_TO3)))
                             + '  '     + str(R_str.format(float(R_TO3)))
                             + '  '     + str(t_str.format(float(t_TO3))))
           output.write('\n' + 'TO4 = ' + str(T_str.format(float(T_TO4)))
                             + '  '     + str(U_str.format(float(U_TO4)))
                             + '  '     + str(U_str.format(float(u_j_TO4)))
                             + '  '     + str(U_str.format(float(V_TO4)))
                             + '  '     + str(R_str.format(float(D_TO4)))
                             + '  '     + str(t_str.format(float(s_TO4)))
                             + '  '     + str(R_str.format(float(R_TO4)))
                             + '  '     + str(t_str.format(float(t_TO4))))
           output.write('\n' + 'CL1 = ' + str(T_str.format(float(T_CL1)))
                             + '  '     + str(U_str.format(float(U_CL1)))
                             + '  '     + str(U_str.format(float(u_j_CL1)))
                             + '  '     + str(U_str.format(float(V_CL1)))
                             + '  '     + str(R_str.format(float(D_CL1)))
                             + '  '     + str(t_str.format(float(s_CL1)))
                             + '  '     + str(R_str.format(float(R_CL1)))
                             + '  '     + str(t_str.format(float(t_CL1))))
           output.write('\n' + 'CL2 = ' + str(T_str.format(float(T_CL2)))
                             + '  '     + str(U_str.format(float(U_CL2)))
                             + '  '     + str(U_str.format(float(u_j_CL2)))
                             + '  '     + str(U_str.format(float(V_CL2)))
                             + '  '     + str(R_str.format(float(D_CL2)))
                             + '  '     + str(t_str.format(float(s_CL2)))
                             + '  '     + str(R_str.format(float(R_CL2)))
                             + '  '     + str(t_str.format(float(t_CL2))))
           output.write('\n' + 'CR  = ' + str(T_str.format(float(T_CR )))
                             + '  '     + str(U_str.format(float(U_CR )))
                             + '  '     + str(U_str.format(float(u_j_CR )))
                             + '  '     + str(U_str.format(float(V_CR )))
                             + '  '     + str(R_str.format(float(D_CR )))
                             + '  '     + str(t_str.format(float(s_CR )))
                             + '  '     + str(R_str.format(float(R_CR )))
                             + '  '     + str(t_str.format(float(t_CR ))))
           output.write('\n' + 'L   = ' + str(T_str.format(float(T_L  )))
                             + '  '     + str(U_str.format(float(U_L  )))
                             + '  '     + str(U_str.format(float(u_j_L  )))
                             + '  '     + str(U_str.format(float(V_L  )))
                             + '  '     + str(R_str.format(float(D_L  )))
                             + '  '     + str(t_str.format(float(s_L  )))
                             + '  '     + str(R_str.format(float(R_L  )))
                             + '  '     + str(t_str.format(float(t_L  ))))
           output.write('\n')
   #        output.write('\n' + 'R   = ' + str(T_str.format(float(T_R  )))
                 #            + '  '     + str(U_str.format(float(U_R  )))
               #              + '  '     + str(U_str.format(float(u_j_R  )))
                #             + '  '     + str(U_str.format(float(V_R  )))
               # #             + '  '     + str(R_str.format(float(D_R  )))
                #             + '  '     + str(t_str.format(float(s_R  )))
                #             + '  '     + str(R_str.format(float(R_R  )))
                #             + '  '     + str(t_str.format(float(t_R  ))))

           output.close     
      import gpkit 
from gpkit import Model, parse_variables, Vectorize, SignomialEquality,Variable,units
from mission import *
from solwriter import *
import math
import numpy as np
import matplotlib.pyplot as plt
from decimal import *
pi = math.pi
from sens_chart import *


def RegularSolve():
#for blownwing
    M = Mission(wingmode ='blownwing')
    M.cost =1/M.R
    sol = M.localsolve(solver='cvxopt')
    #sd = get_highestsens(M, sol, N=10)
    #f, a = plot_chart(sd)
    #f.savefig("sensbar.pdf", bbox_inches="tight")
    print (sol(M.R))
    print (sol(M.aircraft.mass))
    print (sol(M.cruise.perf.P))
    print(sol(M.loading.wingl.w))
    print(M.aircraft)
    print(sol(M.CLmax))
    #print (sol["sensitivities"]["constants"]["CLCmax"])
    writeSolBW(sol)
    writePropBW(sol,M)
    writeWgtBW(sol,M)
    #for conventional wing
    M = Mission(wingmode ='na')
   # M.substitutions.update({M.aircraft.bw.wing.planform.S:134.22})
   # M.substitutions.update({M.aircraft.bw.wing.planform.AR:8.79})
   # M.substitutions.update({M.aircraft.bw.wing.planform.b:34.34})
    M.cost =1/M.R
    sol = M.localsolve(solver='cvxopt')
    # print M.program.gps[-1].result.summary()
    # print sol.summary()
    #sd = get_highestsens(M, sol, N=10)
    #f, a = plot_chart(sd)
    #f.savefig("sensbar.pdf", bbox_inches="tight")
    print (sol(M.R))
    print (sol(M.aircraft.mass))
    print(sol(M.CLmax))
   # print(sol(M.aircraft.bw.wing.spar.laoding.w))
    #print(sol(M.AircraftLoading.Sparloading))
    #print (sol["sensitivities"]["constants"]["CLmax"])
    writeSolNW(sol)
    writePropNW(sol,M)
    writeWgtNW(sol,M)

    
def RangeMassplot():
   M = Mission(wingmode='na')
   Mass_sweep = np.linspace(700,5000,10)
   M.substitutions.update({M.aircraft.mass:('sweep',Mass_sweep)})
   M.cost = 1/M.R
   sol = M.localsolve(solver='cvxopt',skipsweepfailures=True)
   #print (sol.summary())
   plt.plot(sol(M.R),sol(M.aircraft.mass),label='Wing')
   M = Mission(wingmode="blownwing")
   M.substitutions.update({M.aircraft.mass:('sweep',Mass_sweep)})
   M.cost =1/M.R
   sol = M.localsolve(solver='cvxopt',skipsweepfailures=True)
   plt.plot(sol(M.R),sol(M.aircraft.mass),label='Blown Wing')
   plt.legend()
   plt.title("Mass-range diagram")
   plt.xlabel("Range [nmi]" , size = 16) # weight = "medium"
   plt.ylabel("Mass [kg]", size = 16) # weight = "medium"
   plt.savefig("mass-range.png", bbox_inches="tight", format='png', dpi=1000)
   plt.grid()
   plt.show()

def MassRunway():
    M = Mission(wingmode='na')
    Mass_sweep = np.linspace(50,500,10)
    M.substitutions.update({M.Srunway:('sweep',Mass_sweep)})
    M.cost = M.aircraft.mass
    sol = M.localsolve(solver='cvxopt',skipsweepfailures=True)
    print (sol(M.aircraft.mass))
    plt.plot(sol(M.Srunway),sol(M.aircraft.mass),label='Wing')
    M = Mission(wingmode="blownwing")
    Mass_sweep = np.linspace(10,200,10)
    M.substitutions.update({M.Srunway:('sweep',Mass_sweep)})
    M.cost =M.aircraft.mass
    sol = M.localsolve(solver='cvxopt',skipsweepfailures=True)
    plt.plot(sol(M.Srunway),sol(M.aircraft.mass),label='Blown Wing')
    print (sol(M.aircraft.mass))
    plt.legend()
    plt.title("Mass-range diagram")
    plt.xlabel("Srunway" , size = 16) # weight = "medium"
    plt.ylabel("Mass [kg]", size = 16) # weight = "medium"
    plt.savefig("mass-range.png", bbox_inches="tight", format='png', dpi=1000)
    plt.grid()
    plt.show()
    
def Powerusage():
    M=Mission(wingmode="na")
    Mass_sweep = np.linspace(50,500,10)
    M.substitutions.update({M.Srunway:('sweep',Mass_sweep)})
    M.cost = M.aircraft.mass
    sol = M.localsolve(solver='cvxopt',skipsweepfailures=True)
    print (sol(M.aircraft.dynamic.P))
    plt.plot(sol(M.Srunway),sol(M.aircraft.mass),label='Wing')
    M = Mission(wingmode="blownwing")
    Mass_sweep = np.linspace(10,200,10)
    M.substitutions.update({M.Srunway:('sweep',Mass_sweep)})
    M.cost =M.aircraft.mass
    sol = M.localsolve(solver='cvxopt',skipsweepfailures=True)
    plt.plot(sol(M.Srunway),sol(M.aircraft.mass),label='Blown Wing')
    print (sol(M.aircraft.mass))
    plt.legend()
    plt.title("Mass-range diagram")
    plt.xlabel("Srunway" , size = 16) # weight = "medium"
    plt.ylabel("Mass [kg]", size = 16) # weight = "medium"
    plt.savefig("mass-range.png", bbox_inches="tight", format='png', dpi=1000)
    plt.grid()
    plt.show()
if __name__ == "__main__":
  # RangeMassplot()
   #MassRunway()
   RegularSolve()
   